# 汇编语言

posted: 2024-01-03
updated: 2024-01-03

学习笔记 基于《汇编语言》 第四版 王爽 

## 一、基础知识

微处理器使用高电平低电平控制其他硬件，来输出命令，早期的程序使用机器语言，将0、1数字编成程序代码打在纸带或卡片上，1表示打孔，0不打孔。

后来为了方便记忆和书写源程序，诞生了汇编语言，将汇编语言输入编译器可以编译得到机器码。

汇编语言主要由三类指令组成：

1.汇编指令 2.伪指令（编译器执行） 3.其他符号（编译器识别）

存储器的作用相当于内存，存放指令和数据

一个存储器被分为多个内存单元，一个存储单元储存一个Byte，即8个二进制位。字单元由两个字节组成，两个内存单元储存一个字

按功能和链接上，存储器可以被分为两类：随机存储器RAM和只读存储器ROM。RAM断电丢失，但读写速度快。所以计算机的内存和显卡显存都使用的是RAM，需要断电存储的情况使用ROM，例如BIOS

CPU对存储器的读写过程：

![Untitled](%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%201dafc14f5d7e4ff0a5f9ec61d22c83a1/Untitled.png)

1. cpu通过地址总线先将地址信息3发出
2. cpu通过控制总线发出内存读命令
3. 存储器将3号单元的数据8通过数据总线送入cpu（8086的数据总线宽度为16）

ARM架构：过去称作进阶精简指令集机器(Advanced RISC Machine)，是一个32位精简指令集(RISC)处理器架构，依靠简单指令的组合迭代完成复杂指令，由于节能的特点，被广泛地使用在许多嵌入式系统设计。

X86架构：最先是由intel提出，由amd发展成为x86-64结构，x86是微处理器执行的复杂指令集，可以直接用cpu硬件实现复杂指令。

tips: 一个内存单元是1字节，两个16进制位，一个字是两字节，四个16进制位，dd是四字节，8个十六进制位，

1 dd(double word ) = 2 字= 4 字节=4 内存单元 = 8 十六进制位 = 32 二进制位

## 二、寄存器

一个cpu由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。

### 通用寄存器

8086的所有寄存器的位数都是16位的，可以分为高低两块，例如AX可以分为AH和AL

一个字是16位的，刚好可以放入一个16位的寄存器中

8086是16位结构的cpu，其结构特性体现在以下几个方面：

1.运算器一次最多可以处理16位的数据

2.寄存器的最大宽度为16位

3.寄存器和运算器之间的通路为16位

### 生成物理地址：

![Untitled](%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%201dafc14f5d7e4ff0a5f9ec61d22c83a1/Untitled%201.png)

![Untitled](%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%201dafc14f5d7e4ff0a5f9ec61d22c83a1/Untitled%202.png)

也可以把它想成以一种分段的视角来管理内存，一个物理地址由段地址和偏移地址组成。

段的起始地址必然是16的倍数；偏移地址为16位，16位地址的寻址能力是64KB，所以一个段的最大长度为64KB

8086中CS为代码段寄存器，IP为指令指针寄存器。刚启动或复位时CS和IP被设置为CS=FFFFH，IP=0000H，CPU从内存FFFF0H中读取指令执行

若想修改CS\IP寄存器的内容，可以用 `jmp 段地址:偏移地址` ，`jmp ax` 用ax寄存器中的值修改IP

tips：没法直接用数据给段寄存器赋值，例如CS，SS，DS，所以一般先传给AX，再传给段寄存器

## 三、寄存器（内存访问）

通过汇编读取特定内存单元的数据：

`mov bx,1000H`

`mov ds,bx`            DS寄存器存放段地址

`mov al,[0]`           [ … ] 表示一个内存单元，括号里的内容表示内存单元的**偏移地址**（也可以用段地址寄存器显式的定义段地址，例如CS:[…]，SS:[…]，默认段地址是DS）

### 栈机制

8086提供指令`push`和 `pop`来进行栈操作（注意：入栈和出栈都是以字为单位进行的），栈底为高地址，栈顶为低地址。

`push ax`  把ax寄存器中的值压入栈内

`pop ax`   把栈顶元素出栈，并赋值给ax寄存器

cpu通过读取段寄存器SS和偏移地址寄存器SP，来确定栈顶元素。任意时刻，SS:SP 指向栈顶元素的地址，若栈顶为空时，则指向栈低地址的后一个元素。

执行 `push ax` 时，主要由以下两步完成：

1) . SP = SP -2  SS:SP指向当前栈顶前面的元素，以当前栈顶前面的单元作为新的栈顶

2) . 将ax中的内容送入 SS:SP 指向的内存单元处

执行 `pop ax` 时，主要由以下两步完成：

1) . 将SS:SP指向的内存单元处中的内容送入 ax 寄存器

2) . SP = SP + 2  SS:SP指向当前栈顶下面的元素，以当前栈顶下面的单元作为新的栈顶

![Untitled](%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%201dafc14f5d7e4ff0a5f9ec61d22c83a1/Untitled%203.png)

tips：

1. 目前8086中并没有寄存器去规定栈的范围，只有SS:SP 去规定栈顶的位置，所以如果超出规划的栈，则很有可能会修改其他数据。
2. 栈顶溢出的操作并不会影响SS寄存器，意味着如果溢出，栈顶将环绕，覆盖原本栈中的内容

例：将 10000H~1FFFFH 当作栈段，此时栈顶指针指向 SS=1000H ，SP = 0000H，此时进行入栈`push`，SS寄存器不变，SP-2 变为 FFFEH，将在 1FFFEH的位置写入数据

1. `push/pop`指令只支持 字 操作
2. x86汇编不支持直接将一个内存地址的数据直接转移到另一个内存地址的数据，需要先储存到中间寄存器中再进行赋值

### 段

实际上CPU中不存在段的定义，段是我们自己的定义的一个代码块

与DS相关的，被称为数据段，调用mov等指令时，会默认使用DS指定的数据带

与CS相关的，被称为代码段，cpu从CS:IP指向的地址取指令

与SS相关的，被称为栈段，SS:SP指定栈指针的位置

## 五、[BX]和 loop指令

[bx] 表示一个内存单元，它的偏移地址在 bx 寄存器中

例如：`mov ax,[bx]`

表示将一个字的内容送入ax，这个字的段地址在ds中，偏移地址在bx中

一个经典的循环写法：

```nasm
mov cx,11
s:   add ax,ax
loop s
```

执行loop操作时，进行两步操作（先将cx减1，再进行判断）

1. cx=cx-1
2. 判断cx中的值，不为0则转至s处执行

tips: 汇编源程序中，数据不能以字母开头，如果是字母开头的，前面要加0，例如A000H要写成0A000H

## 六、包含多个段的程序

### 在代码段中使用数据

```nasm
assume cs:code
code segment
dw 1111h,2222h,3456h,5555h,7777h,8756h,0ac34h,6756h
mov bx,0
...
code ends
```

dw 定义字数据， db 定义字节数据

因为dw放在cs(code)代码段内，所以dw段地址为cs，偏移地址就是代码内的位置，因为这里是处于代码段的开头，所以偏移地址为0

8086根据CS:IP指向的地址为执行代码的起始段。根据上面的代码，起始位置将会指向dw数据存储的地址，数据不可以作为代码执行，通过`start`可以指定新的代码起始执行位置，例如：

```nasm
start: mov ax,stack
mov ss,ax
mov sp,16
mov ax,data
mov ds,ax
push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]
mov ax,4c00h
int 21h
code ends
end start （☆）
```

### 将数据、代码、栈放入不同的段

```nasm
assume cs:code, ds:data , ss:stack
data segment:
...
data ends
stack segement
...
stack ends
code segment
...
code ends
end
```

实验表明： data的值和ds不是一一对应的，对于stack来说也是一样的，而是按定义顺序从ds段地址计算得到，留ds+10H作为程序通信，后面地址分配就按源程序的区块顺序 （这里ds段地址总是定的不知道为什么）

为什么要用assume定义ds：data？          **存疑**

要用assume把段跟段寄存器对应起来的原因是原来的DOS找到的空闲内存的地址不是固定的，无法找到一个地址在任何时候都是空闲的。于是DOS需要可以重定位的程序，而当时的定位方式就是设置段寄存器的值使该程序能在可分配（空闲）的内存中可用。那就需要知道某个段被重定位时候需要修改哪个段寄存器的值才能正确执行。assume提供这种段和重定位代码时需要对应修改的寄存器的关系给编译器，编译器再这个信息写到二进制文件中去。比如DOS下的exe程序记录在文件头中。

## 七、更灵活的定位内存地址的方法

and指令：逻辑与指令，按位进行与运算

```nasm
mov al,01100011B
and al,00111011B
```

or指令：逻辑或指令，按位进行或运算

汇编中所有的字符储存都是参照 ASCII 码表进行的

小写字母的ASCII码值比大写字母的码值大20H，如果以二进制位的形式来看，小写字母的第五位是0，大写字母第五位是1

可以用[bx+idata]的方式指示内存单元

tips:

1.使用双层循环的时候，要注意修改cx的值，因为两层循环都共享一个cx寄存器

2.如果需要暂存数据，一般使用 栈

## 八、数据处理的两个基本问题

只有 bx、si、di、bp四个寄存器可以使用[…]来进行内存单元的寻址

只要包含[ds]的指令，段地址默认在ss寄存器中，其他指令默认在ds寄存器中

![Untitled](%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%201dafc14f5d7e4ff0a5f9ec61d22c83a1/Untitled%204.png)

可以用word ptr 去指明访问的内存空间是一个字单元，byte ptr是一个字节单元

```nasm
mov word ptr ds:[0],1

inc byte ptr [bx]
```

div：除法指令

        除数：放在内存单元中

        被除数: 

                  如果除数为8位，被除数为16位，默认放在AX中，AL存放除法操作的商，AH存放余数

                  如果除数为16位，被除数则为32位，存放在DX和AX中，DX高16位，AX低16位存放操作的商，DX存放除法操作的余数    

```nasm
mov dx,1
mov ax,86A1H
mov bx,100
div bx              div 除数
```

dd：第一双字型数据，用法和db、dw类似，都是由编译器处理识别的

dup：进行数据重复操作，方便定义数据

```nasm
db 3 dup (0)           定义三个字节，他们的值都是0
 
db 3 dup (1,2,3)       定义九个字节，值是0 1 2 0 1 2 0 1 2
```

tips:  dd 3,7 分配地址

03 00 00 00 07 00 00 00

从低字节→高字节开始储存

## 九、转移指令的原理

offset 操作符： 取得标号地址的偏移地址

```nasm
start: move ax, offset start      相当于 mov ax,0
    s: mov ax,offset s            相当于 mov ax,3
```

jmp指令：

`jmp short s`         CS:IP 转向s 处，short标号表示限定的是段内短转移，IP修改范围位-128~127, 在对                  于的机器码中，会把 标号s 转化为对应的偏移地址

`jmp near ptr s`   实现16位的段内近转移

`jmp far ptr s`             实现段间转移（远转移），修改CS和IP

`jmp word ptr ds:[0]`   段内转移，先把ds:[0] 指向的内存单元值给IP

`jmp dword ptr ds:[0]` 段间转移，先把ds:[0] 指向的内存单元值给IP，再将接下来的字给CS 

  （CS）=（内存单元地址+2）

  （IP）=（内存单元地址）

jcxz指令： 如果cx=0，则跳转到标号处执行，只支持短转移，ip修改范围为-128~127

短指令跳转储存的是相对的偏移地址，而不是绝对偏移地址

## 十、CALL和RET指令

ret指令用栈中的数据，修改IP的内容，从而实现近转移

执行下面两步操作：

(IP)=((ss)*16+(sp))

(sp)=(sp)+2

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移.先赋值IP再赋值CS

(IP)=((ss)*16+(sp))

(sp)=(sp)+2

(CS)=((ss)*16+(sp))

(sp)=(sp)+2

`call s` ：将当前的IP压栈后，转到标号处执行指令

(sp)=(sp)-2

((ss)*16+(sp))=(IP)

(IP)=(IP)+16位位移

`call far ptr s`：实现段间转移  先push CS，再push IP，再跳转

`call word ptr ds:[0]` : 实现的意义和ret差不多，只不过在跳转前增加push当前地址的动作

`call dword ptr ds:[0]` :

mul 指令：  如果是八位相乘，一个默认放在AL中，另一个放在输入的寄存器或地址中，结果放在AX中（imul: 有符号位的乘积）

如果是16位相乘，默认放在AX中，另一个放在输入的寄存器或地址中，结果高位放在DX中，低位放在AX中

tips: 在机器码中，表示一个字，低八位先出现，高八位后出现，和直观的书写16进制相反

例如 `mov ax,03E8H`   的机器码表示为   B8 E8 03 

子程序的设计思路：

子程序中使用的寄存器入栈  (寄存器有限，避免重复使用/ 数据可以用内存地址传递)

子程序内容

子程序中使用的寄存器出栈

返回(ret、retf)

## 十一、标志寄存器

8086 中 flag寄存器被称为标志寄存器，用来储存标志位

![Untitled](%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%201dafc14f5d7e4ff0a5f9ec61d22c83a1/Untitled%205.png)

ZF标志：第六位，零标志位。它记录相关指令执行后，其结果是否为0，如果是0，则zf=1；如果不为0，那么zf=0。

PF标志：第二位，奇偶标志位。判断结果的所有bit位中1的个数是否为偶数。若为偶数个，pf=1，如果为奇数，pf=0。

SF标志：第七位，符号标志位。判断第一位是否为1（如果存储的是有符号数，那么作用是判断储存数的正负）。若为1（负），则SF=1。若为0（正），则SF=0.

上述标志只被被add、sub指令影响

CF标志：第0位，进位标志位。判断是是否进位（对于无符号数来说），若进位，则cf=1，否则cf=0。

OF标志：第十一位，溢出标志位。判断是否溢出（对于有符号数来说），检测是否影响第一位的大小，若溢出，则of=1，否则0。

`adc`指令： adc ax,bx      实现的功能：(ax) = (ax) + (bx) + CF

`sbb`指令： sbb ax,bx      实现的功能：(ax) = (ax) - (bx) - CF

`cmp`指令：cmp ax,bx     实现的功能：计算操作对象ax-bx，但是不保存结果，只改变标志位

条件转移指令： 

je  等于则转移                 jne 不等于则转移                 jge 有符号大于等于跳转        

jb 低于则转移                  jnb  不低于则转移               

ja 高于则转移                  jna  不高于则转移                jg 大于转移指令

串传送指令：

`movsb/movsw`  将ds:si指向的内存单元中的字节(字)送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减。 df=0 递增，df=1 递减

`rep movsb` 相当于

s:movsb

loop s

根据cx的值，重复执行后面的串传送指令，实现cx个字节的传送

`cld`指令：将df置为0（递增）

`std`指令：将df置为1（递减）

`pushf` 将标志寄存器（所有位）入栈

`popf`  从栈中弹出数据，送入标志存储器中

## 十二、内中断

中断的意思是指，CPU不再接着刚执行完的指令向下执行，而是转去处理这个特殊信息

8086中有四种情况会产生中断：

1.除法错误

2.单步执行

3.执行into指令

4.执行int指令

用中断类型码来标识中断信息的来源，中断类型码为一个字节型数据，能够表示256种中断信息的来源。

接收到中断信息后，能够跳转到中断处理程序中进行处理，即需要将CS:IP指向中断处理程序的入口地址，这个入口地址储存在中断向量表中，一个中断类型码对应段地址和偏移地址，中断向量表指定放在内存地址0处，即内存0000：0000到0000：03FF的1024个单元，一个表项占用两个字，高地址字存放段地址，低地址存放偏移地址

例如中断向量表在内存中的表示为0000：0000 68 10 A7 00 ， 则它的入口地址为：00A7:1068

中断过程：

1.从中断信息中取得中断类型码

2.标志寄存器的值入栈（pushf）

3.设置标志存储器的第8位TF和第9位IF值为0

4.cs的内容入栈

5.ip的内容入栈

6.从内存地址为中断类型码*4 和 中断类型码*4 +2 的两个字节单元读取并设置IP和CS

单步中断：

若TF=1 则在执行完一条指令之后，会触发单步中断：所有寄存器中的内容被显示在屏幕上，并等待输入命令。所以为避免套娃，在中断过程中都会将TF位置为0

响应中断的特殊情况： 为了ss和sp栈地址能够正确的设置，ss指令执行后不进行单步中断，将会连续执行下一步操作

## 十三、 int指令

`int n` 引发编号为n的中断过程

`iret` 指令恢复int 指令执行前的标志寄存器和CS、IP的值，从而接着执行之前的程序（类似于call和ret指令的成对使用）使用时，注意其他寄存器的保存

BIOS和DOS都提供了一套完整的中断例程

BIOS中断例程的安装过程：

1.cpu一上电，初始化CS=0FFFFH，(IP)=0，自动从FFFF:0处开始执行程序，FFFF:0处有一条跳转指令，执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序

1. 将建立BIOS所支持的中断向量，将BIOS提供的中断例程的入口地址登记在中断向量表中
2. 初始化完成后，调用 `int 19H` 进行操作系统的引导，从此将计算机交由操作系统控制
3. DOS将所提供的中断例程装入内存

tips：BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号，例如返回程序 mov ax,4c00H int 21H，采用的就是4c号子程序

## 十四、端口

在访问端口的时候，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过地址总线相连（在同一个寻址系统中），最多可以定位64KB个不同的端口

不能使用mov/add/push等指令，只能用in和out，分别从端口读取和写入数据

in 和 out指令中只能使用ax或al来存放写入或读入的数据

对0~255以内的端口进行读写时：

```nasm
in al,20H
out 20H,al
```

对256~65535的端口进行读写时，端口号放在dx中

```nasm
mov dx,3f8H
in al,dx
out dx,al
```

shl 是逻辑左移命令，将移出的一位写入CF中，最低位用0补充。如果移动的位数大于1，则必须将移动位数放入cl中

shr 是逻辑右移命令

## 十五、外中断

外中断是指当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片(外设)向CPU发出相应的中断信息

可以分为两类：

1. 可屏蔽中断：CPU可以不响应的中断，如果IF=1，则CPU在执行完当前指令后响应中断；IF=0，不响应中断

sti 设置IF=1

cli 设置IF=0

  2.不可屏蔽中断

中断类型码固定为2，几乎所有由外设引发的外中断，都是可屏蔽中断

## 十六、直接定址表

```nasm
code segment
a:db 1,2,3,4,5,6,7,8     a 和 b 都代表的是标号，仅代表了内存单元的地址
b:dw 0 
```

```nasm
code segment
a db 1,2,3,4,5,6,7,8      a 和 b 同时描述内存地址和单元长度
b dw 0

例如： mov al,b 会报错，b代表了字长度
但是在检测点中表名 b[si]的这种格式可以不定长度？？
```

如果要使用数据标号，则必须在assume中将数据标号所在的段和一个段寄存器联系起来，否则在编译的时候，无法确定标号的段地址在哪个寄存器中

```nasm
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
c dw a,b                 a,b 处储存的是标号a,b的偏移地址
c dw offset a, offset b
data ends
```

```nasm
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
c dd a,b                 a,b 处储存的是标号a,b的偏移地址,段地址
c dd offset a,seg a,offset b,seg b
data ends
```

## 十七、使用BIOS进行键盘输入和磁盘读写

## 常用指令

`REPNE SCASA`  

REPNE 如果Zero Flag和 CX/ECX不是零，则继续后续的操作

SCASA 比较AL寄存器和ES:DI指向的

`test destination,source` 对destination和source位进行与操作，但不保存结果

```nasm
test al,1          检测最低位是否为1
jz bit_is_clear
```

`neg operand`    将一个数转换成它的补码形式，同时影响标志位的值，OF/ZF/SF/CF

`xchg operand1 operand2`  交换两个操作数的内容